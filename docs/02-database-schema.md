# Database Schema Documentation

## Overview

The Financier uses SQLite as the local database, accessed through Prisma ORM. The schema is designed to be normalized, efficient for queries, and extensible for future features.

**Database Location**: `~/.financier/data.db`

## Schema Design Principles

1. **Normalization**: Separate accounts and transactions into distinct tables
2. **Flexibility**: Support multiple currencies, account types, and banks
3. **Performance**: Indexes on commonly queried fields
4. **Auditability**: Track import timestamps and sources
5. **Deduplication**: Use external IDs and composite keys to prevent duplicates

## Tables

### accounts

Stores information about financial accounts (bank accounts, credit cards, etc.)

**Purpose**:

- Track multiple accounts from different banks
- Store account-level metadata
- Enable account-specific queries

**Fields**:

- `id` (String, Primary Key) - IBAN (required, user-provided for all accounts)
- `name` (String) - User-friendly account name (required, manually set)
- `openDate` (DateTime, Optional) - When account was opened (manually set)
- `openingBalance` (Decimal, Optional) - Initial account balance (manually set)
- `currentBalance` (Decimal, Optional) - Current account balance (stored, updated on import)
- `currency` (String) - Primary account currency (ISO 4217 code)
- `bankCode` (String) - Which bank this account belongs to
- `isActive` (Boolean) - Whether account is active (default: true)
- `createdAt` (DateTime) - When account was first created
- `updatedAt` (DateTime) - Last time account was updated

**Constraints**:

- Primary key on `id`

**Indexes**:

- Primary key index (automatic)
- Index on `bankCode` for filtering by bank

**Notes**:

- `id` contains the actual IBAN (not hashed)
- IBAN is required for all accounts, even cards/Revolut (user must provide)
- Database is local (~/.financier/data.db), privacy via OS permissions
- Last 4 digits (mask) calculated from `id` for UI display (e.g., `id.slice(-4)`)
- Account metadata (name, openDate, openingBalance) must be manually set by user
- One account = one currency. Multi-currency transactions stored with original amount/currency fields

---

### transactions

Stores individual financial transactions

**Purpose**:

- Record all financial movements
- Enable queries, analysis, and reporting
- Track original data for audit purposes

**Fields**:

- `id` (String, Primary Key) - UUID generated by application
- `accountId` (String, Foreign Key → accounts.id) - IBAN of the account
- `counterpartyAccountId` (String, Optional, Foreign Key → accounts.id) - IBAN of counterparty account for internal transfers
- `date` (DateTime) - Transaction date (from bank statement)
- `amount` (Decimal) - Transaction amount in account currency (negative for debits, positive for credits)
- `currency` (String) - Account currency (ISO 4217)
- `originalAmount` (Decimal, Optional) - Original transaction amount if currency conversion occurred
- `originalCurrency` (String, Optional) - Original transaction currency if different from account currency
- `merchant` (String, Optional) - Merchant/payee name
- `description` (String) - Original transaction description from bank
- `category` (String, Optional) - User-assigned category
- `type` (String) - Transaction type: "debit", "credit", "transfer"
- `balance` (Decimal, Optional) - Account balance after this transaction
- `externalId` (String, Optional) - Bank's unique transaction identifier
- `source` (String) - Which bank/import this came from
- `importedAt` (DateTime) - When this transaction was imported
- `createdAt` (DateTime) - Record creation timestamp
- `updatedAt` (DateTime) - Record update timestamp

**Constraints**:

- Primary key on `id`
- Foreign key: `accountId` references `accounts.id`
- Foreign key: `counterpartyAccountId` references `accounts.id` (optional)
- Unique constraint on `(accountId, date, externalId)` for duplicate prevention
- Check constraint: `amount != 0`

**Indexes**:

- Primary key index (automatic)
- Index on `accountId` (for account-specific queries)
- Index on `counterpartyAccountId` (for finding internal transfers)
- Composite index on `(accountId, date)` (for date range queries)
- Index on `date` (for global date range queries)
- Index on `merchant` (for merchant-specific queries)
- Index on `category` (for category-based analysis)
- Unique index on `(accountId, date, externalId)` (for duplicate detection)

**Notes**:

- Amount sign convention: negative = money out, positive = money in
- `externalId` may not exist for all banks (use NULL or generate synthetic ID)
- `balance` is optional (not all banks provide running balance)
- `description` is immutable (original from bank), `category` is user-editable
- **Internal transfers**: When `counterpartyAccountId` is set AND references user's account
- Multi-currency: `originalAmount`/`originalCurrency` capture pre-conversion values (e.g., 649 SEK → 59.22 EUR)

---

## Relationships

```
accounts (1) ──< (many) transactions (via accountId)
accounts (1) ──< (many) transactions (via counterpartyAccountId, optional)
```

- One account has many transactions (via `accountId`)
- One account can be the counterparty in many transactions (via `counterpartyAccountId`)
- Each transaction belongs to exactly one account
- Each transaction optionally references a counterparty account (for internal transfers)

## Prisma Schema Template

**Location**: `packages/db/prisma/schema.prisma`

**Schema**:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Account {
  id             String   @id // IBAN (user-provided)
  name           String
  openDate       DateTime?
  openingBalance Decimal?
  currentBalance Decimal?
  currency       String
  bankCode       String
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  transactions     Transaction[] @relation("AccountTransactions")
  counterpartyTxns Transaction[] @relation("CounterpartyTransactions")

  @@index([bankCode])
  @@map("accounts")
}

model Transaction {
  id                    String    @id @default(uuid())
  accountId             String
  counterpartyAccountId String?
  date                  DateTime
  amount                Decimal
  currency              String
  originalAmount        Decimal?
  originalCurrency      String?
  merchant              String?
  description           String
  category              String?
  type                  String
  balance               Decimal?
  externalId            String?
  source                String
  importedAt            DateTime  @default(now())
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  account               Account   @relation("AccountTransactions", fields: [accountId], references: [id])
  counterpartyAccount   Account?  @relation("CounterpartyTransactions", fields: [counterpartyAccountId], references: [id])

  @@unique([accountId, date, externalId])
  @@index([accountId])
  @@index([counterpartyAccountId])
  @@index([accountId, date])
  @@index([date])
  @@index([merchant])
  @@index([category])
  @@map("transactions")
}
```

**Notes**:

- Prisma uses `Decimal` type for precise monetary values (maps to SQLite TEXT internally)
- `@default(uuid())` generates UUIDs for transaction IDs
- Account.id contains IBAN directly (no @default, user-provided)
- Two named relations on Account to handle both `accountId` and `counterpartyAccountId` foreign keys
- `@@map` directives keep table names in snake_case

## Environment Variables

**DATABASE_URL**: Connection string for Prisma

**Development**:

```bash
DATABASE_URL="file:~/.financier/data.db"
```

**Testing**:

```bash
DATABASE_URL="file:./test.db"
```

## Migrations

### Migration Strategy

- Prisma Migrate for schema changes
- Migrations stored in `packages/db/prisma/migrations/`
- Auto-run migrations on first use
- Manual migration command (future): `financier db migrate`

### Initial Migration

```bash
cd packages/db
npx prisma migrate dev --name init
```

Creates initial database schema and migration files.

### Future Migrations

When schema changes:

```bash
cd packages/db
npx prisma migrate dev --name
```

## Data Types

### Monetary Values

Use **Decimal** type via Prisma:

- Precise decimal arithmetic
- No floating-point errors
- SQLite stores as TEXT internally
- JavaScript uses `Decimal` from decimal.js

```typescript
import { Decimal } from '@prisma/client/runtime';

const amount = new Decimal('123.45');
```

### Dates

Use **DateTime** type via Prisma:

- Stored as ISO 8601 strings in SQLite
- JavaScript Date objects in application
- Timezone-aware (store in UTC, convert for display)

```typescript
const transactionDate = new Date('2025-11-22T10:30:00Z');
```

### Currency Codes

Use **ISO 4217** three-letter codes:

- EUR, USD, GBP, etc.
- Stored as String(3)
- Validated via Zod schema

## Duplicate Detection

### Strategy

Transactions are considered duplicates if they match on:

1. **accountId** - Same account
2. **date** - Same transaction date
3. **externalId** - Same bank transaction ID

**Implementation**:

```sql
UNIQUE (accountId, date, externalId)
```

### Handling Missing externalId

If bank doesn't provide transaction IDs:

- Use combination of date + amount + description
- Hash the combination to create synthetic externalId
- Store hash in externalId field

```typescript
function generateExternalId(transaction: ParsedTransaction): string {
  if (transaction.externalId) {
    return transaction.externalId;
  }

  const data = `${transaction.date}|${transaction.amount}|${transaction.description}`;
  return createHash('sha256').update(data).digest('hex').substring(0, 32);
}
```

## Query Patterns

### Common Queries

**Get all transactions for an account**:

```typescript
const transactions = await db.transaction.findMany({
  where: { accountId: 'LT000000000000000004' },
  orderBy: { date: 'desc' },
});
```

**Get transactions in date range**:

```typescript
const transactions = await db.transaction.findMany({
  where: {
    date: {
      gte: new Date('2025-01-01'),
      lte: new Date('2025-12-31'),
    },
  },
  orderBy: { date: 'desc' },
});
```

**Get current balance for account**:

```typescript
const latestTransaction = await db.transaction.findFirst({
  where: { accountId: 'LT000000000000000004' },
  orderBy: { date: 'desc' },
  select: { balance: true },
});
```

**Search by merchant**:

```typescript
const transactions = await db.transaction.findMany({
  where: {
    merchant: {
      contains: 'Amazon',
      mode: 'insensitive',
    },
  },
});
```

**Spending by category**:

```typescript
const spending = await db.transaction.groupBy({
  by: ['category'],
  where: {
    type: 'debit',
    date: {
      gte: new Date('2025-11-01'),
      lte: new Date('2025-11-30'),
    },
  },
  _sum: { amount: true },
  _count: true,
});
```

## Data Validation

### At Import Time

Use Zod schemas from `@nodm/financier-types`:

```typescript
import { CreateTransactionInputSchema } from '@nodm/financier-types';

function validateTransaction(data: unknown) {
  return CreateTransactionInputSchema.parse(data);
}
```

### At Query Time

Prisma provides runtime type safety:

```typescript
// TypeScript knows the shape of Transaction
const transaction: Transaction = await db.transaction.findUnique({
  where: { id: 'some-uuid' },
});
```

## Performance Considerations

### Indexes

Current indexes optimize for:

- Account-specific queries (most common)
- Date range queries (very common)
- Merchant/category filtering (common)
- Duplicate detection (critical)

### Batch Operations

For importing large CSVs:

```typescript
// Insert in batches of 1000
await db.transaction.createMany({
  data: transactions,
  skipDuplicates: true, // Skip duplicates instead of erroring
});
```

### Query Limits

Always use pagination for large result sets:

```typescript
const transactions = await db.transaction.findMany({
  take: 100, // Limit
  skip: 0, // Offset
});
```

## Future Schema Extensions

### Planned Additions

1. **categories table**

   - Predefined category list
   - Category hierarchy (parent/child)
   - Custom categories per user

2. **tags table + transaction_tags join table**

   - Multiple tags per transaction
   - Tag-based filtering and analysis

3. **budgets table**

   - Monthly budget limits per category
   - Budget vs actual tracking

4. **recurring_transactions table**

   - Pattern detection for recurring charges
   - Subscription tracking

5. **notes table**
   - User notes on transactions
   - Timestamp and edit history

### Migration Path to PostgreSQL

For cloud deployment:

- Change datasource provider to "postgresql"
- Add UUID extension
- Adjust Decimal type mapping
- Add row-level security policies
- Add user authentication table

## Testing Data

### Test Database

Create separate test database:

```typescript
// In tests
process.env.DATABASE_URL = 'file:./test.db';
```

### Sample Data

Create factory functions for test data:

```typescript
function createTestAccount(overrides = {}) {
  return {
    id: 'TEST_ACCOUNT_001',
    type: 'checking',
    currency: 'EUR',
    bankCode: 'TEST_BANK',
    ...overrides,
  };
}

function createTestTransaction(overrides = {}) {
  return {
    id: uuid(),
    accountId: 'TEST_ACCOUNT_001',
    date: new Date('2025-11-22'),
    amount: new Decimal('-50.00'),
    currency: 'EUR',
    description: 'Test transaction',
    type: 'debit',
    source: 'TEST_BANK',
    ...overrides,
  };
}
```

## Data Retention

### Current Policy

- Keep all data indefinitely
- No automatic deletion
- User can manually delete via future CLI commands

### Future Considerations

- Archival of old transactions (>5 years)
- Compression of historical data
- Export/backup utilities
