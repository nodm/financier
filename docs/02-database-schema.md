# Database Schema Documentation

## Overview

The Financier uses SQLite as the local database, accessed through Drizzle ORM. The schema is designed to be normalized, efficient for queries, and extensible for future features.

**Database Location**: `~/.financier/data.db`

## Schema Design Principles

1. **Normalization**: Separate accounts and transactions into distinct tables
2. **Flexibility**: Support multiple currencies, account types, and banks
3. **Performance**: Indexes on commonly queried fields
4. **Auditability**: Track import timestamps and sources
5. **Deduplication**: Use external IDs and composite keys to prevent duplicates

## Tables

### accounts

Stores information about financial accounts (bank accounts, credit cards, etc.)

**Purpose**:

- Track multiple accounts from different banks
- Store account-level metadata
- Enable account-specific queries

**Fields**:

- `id` (String, Primary Key) - IBAN (required, user-provided for all accounts)
- `name` (String) - User-friendly account name (required, manually set)
- `openDate` (String, ISO 8601) - When account was opened (required, manually set)
- `openingBalance` (String, Decimal) - Initial account balance (optional, manually set)
- `currentBalance` (String, Decimal) - Current account balance (optional, stored, updated on import)
- `currency` (String) - Primary account currency (ISO 4217 code)
- `bankCode` (String) - Which bank this account belongs to
- `isActive` (String) - Whether account is active (default: 'true')
- `createdAt` (String, ISO 8601) - When account was first created
- `updatedAt` (String, ISO 8601) - Last time account was updated

**Constraints**:

- Primary key on `id`

**Indexes**:

- Primary key index (automatic)
- Index on `bankCode` for filtering by bank

**Notes**:

- `id` contains the actual IBAN (not hashed)
- IBAN is required for all accounts, even cards/Revolut (user must provide)
- Database is local (~/.financier/data.db), privacy via OS permissions
- Last 4 digits (mask) calculated from `id` for UI display (e.g., `id.slice(-4)`)
- Account metadata (name, openDate, openingBalance) must be manually set by user
- One account = one currency. Multi-currency transactions stored with original amount/currency fields

---

### transactions

Stores individual financial transactions

**Purpose**:

- Record all financial movements
- Enable queries, analysis, and reporting
- Track original data for audit purposes

**Fields**:

- `id` (String, Primary Key) - UUID generated by application
- `accountId` (String, Foreign Key → accounts.id) - IBAN of the account
- `counterpartyAccountId` (String, Optional, Foreign Key → accounts.id) - IBAN of counterparty account for internal transfers
- `date` (String, ISO 8601) - Transaction date (from bank statement)
- `amount` (String, Decimal) - Transaction amount in account currency (negative for debits, positive for credits)
- `currency` (String) - Account currency (ISO 4217)
- `originalAmount` (String, Decimal, Optional) - Original transaction amount if currency conversion occurred
- `originalCurrency` (String, Optional) - Original transaction currency if different from account currency
- `merchant` (String, Optional) - Merchant/payee name
- `description` (String) - Original transaction description from bank
- `category` (String, Optional) - User-assigned category
- `type` (String) - Transaction type: "debit", "credit", "transfer"
- `balance` (String, Decimal, Optional) - Account balance after this transaction
- `externalId` (String, Optional) - Bank's unique transaction identifier
- `source` (String) - Which bank/import this came from
- `importedAt` (String, ISO 8601) - When this transaction was imported
- `createdAt` (String, ISO 8601) - Record creation timestamp
- `updatedAt` (String, ISO 8601) - Record update timestamp

**Constraints**:

- Primary key on `id`
- Foreign key: `accountId` references `accounts.id`
- Foreign key: `counterpartyAccountId` references `accounts.id` (optional)
- Unique constraint on `(accountId, date, externalId)` for duplicate prevention

**Indexes**:

- Primary key index (automatic)
- Index on `accountId` (for account-specific queries)
- Index on `counterpartyAccountId` (for finding internal transfers)
- Composite index on `(accountId, date)` (for date range queries)
- Index on `date` (for global date range queries)
- Index on `merchant` (for merchant-specific queries)
- Index on `category` (for category-based analysis)
- Unique index on `(accountId, date, externalId)` (for duplicate detection)

**Notes**:

- Amount sign convention: negative = money out, positive = money in
- `externalId` may not exist for all banks (use NULL or generate synthetic ID)
- `balance` is optional (not all banks provide running balance)
- `description` is immutable (original from bank), `category` is user-editable
- **Internal transfers**: When `counterpartyAccountId` is set AND references user's account
- Multi-currency: `originalAmount`/`originalCurrency` capture pre-conversion values (e.g., 649 SEK → 59.22 EUR)

---

## Relationships

```
accounts (1) ──< (many) transactions (via accountId)
accounts (1) ──< (many) transactions (via counterpartyAccountId, optional)
```

- One account has many transactions (via `accountId`)
- One account can be the counterparty in many transactions (via `counterpartyAccountId`)
- Each transaction belongs to exactly one account
- Each transaction optionally references a counterparty account (for internal transfers)

## Drizzle Schema

**Location**: `packages/db/src/schema/`

**accounts.ts**:

```typescript
import { sql } from "drizzle-orm";
import { index, sqliteTable, text } from "drizzle-orm/sqlite-core";

export const accounts = sqliteTable(
  "accounts",
  {
    id: text("id").primaryKey(),
    name: text("name").notNull(),
    openDate: text("openDate").notNull(),
    openingBalance: text("openingBalance"),
    currentBalance: text("currentBalance"),
    currency: text("currency").notNull(),
    bankCode: text("bankCode").notNull(),
    isActive: text("isActive").notNull().default("true"),
    createdAt: text("createdAt").notNull().default(sql`CURRENT_TIMESTAMP`),
    updatedAt: text("updatedAt").notNull().$onUpdate(() => new Date().toISOString()),
  },
  (table) => ({
    bankCodeIdx: index("accounts_bankCode_idx").on(table.bankCode),
  })
);
```

**transactions.ts**:

```typescript
import { sql } from "drizzle-orm";
import { index, sqliteTable, text, unique } from "drizzle-orm/sqlite-core";
import { accounts } from "./accounts.js";

export const transactions = sqliteTable(
  "transactions",
  {
    id: text("id").primaryKey(),
    accountId: text("accountId")
      .notNull()
      .references(() => accounts.id, { onDelete: "restrict" }),
    counterpartyAccountId: text("counterpartyAccountId")
      .references(() => accounts.id, { onDelete: "set null" }),
    date: text("date").notNull(),
    amount: text("amount").notNull(),
    currency: text("currency").notNull(),
    originalAmount: text("originalAmount"),
    originalCurrency: text("originalCurrency"),
    merchant: text("merchant"),
    description: text("description").notNull(),
    category: text("category"),
    type: text("type").notNull(),
    balance: text("balance"),
    externalId: text("externalId"),
    source: text("source").notNull(),
    importedAt: text("importedAt").notNull().default(sql`CURRENT_TIMESTAMP`),
    createdAt: text("createdAt").notNull().default(sql`CURRENT_TIMESTAMP`),
    updatedAt: text("updatedAt").notNull().$onUpdate(() => new Date().toISOString()),
  },
  (table) => ({
    accountIdIdx: index("transactions_accountId_idx").on(table.accountId),
    counterpartyIdx: index("transactions_counterpartyAccountId_idx").on(table.counterpartyAccountId),
    accountDateIdx: index("transactions_accountId_date_idx").on(table.accountId, table.date),
    dateIdx: index("transactions_date_idx").on(table.date),
    merchantIdx: index("transactions_merchant_idx").on(table.merchant),
    categoryIdx: index("transactions_category_idx").on(table.category),
    uniqueConstraint: unique("transactions_accountId_date_externalId_key").on(
      table.accountId,
      table.date,
      table.externalId
    ),
  })
);
```

**Notes**:

- Drizzle stores decimals as TEXT for precision (explicit type)
- UUIDs generated at application level (crypto.randomUUID())
- Account.id contains IBAN directly (user-provided)
- Foreign keys defined with onDelete behavior
- Indexes defined in second parameter of sqliteTable
- Dates and timestamps stored as TEXT in ISO 8601 format for readability and portability
- `updatedAt` uses `.$onUpdate()` with `.toISOString()` to auto-update in ISO format
- `isActive` stored as text 'true'/'false' for SQLite compatibility
- Timestamp defaults use `sql\`CURRENT_TIMESTAMP\`` for SQLite's built-in ISO timestamp

## Environment Variables

**DATABASE_URL**: Connection string for database (e.g., `file:~/.financier/data.db`)

**Development**:

```bash
DATABASE_URL="file:~/.financier/data.db"
```

**Testing**:

```bash
DATABASE_URL="file:./test.db"
```

## Migrations

### Migration Strategy

- Drizzle Kit for schema changes
- Migrations stored in `packages/db/drizzle/`
- Run migrations manually with `npm run db:migrate`
- Push schema directly in development with `npm run db:push`

### Initial Migration

```bash
cd packages/db
npm run db:generate  # Generate migration from schema
npm run db:migrate   # Apply migration to database
```

Creates initial database schema and migration files.

### Future Migrations

When schema changes:

```bash
cd packages/db
npm run db:generate  # Generate new migration
npm run db:migrate   # Apply to database
```

### Development Workflow

For rapid iteration (skips migrations):

```bash
cd packages/db
npm run db:push  # Push schema directly to DB
```

## Data Types

### Monetary Values

Stored as **TEXT** in SQLite via Drizzle:

- SQLite TEXT type provides exact decimal precision
- Avoids floating-point errors
- Application handles conversion to/from string
- Use `Decimal` from `decimal.js` for calculations

```typescript
import { Decimal } from 'decimal.js';

// When inserting
const amount = new Decimal('123.45');
await db.insert(transactions).values({ amount: amount.toString() });

// When reading
const result = await db.select().from(transactions);
const amount = new Decimal(result[0].amount);
```

### Dates

Stored as **TEXT** (ISO 8601 format) via Drizzle:

- SQLite stores as ISO 8601 strings (e.g., '2025-11-22T10:30:00.000Z')
- Application converts Date objects to ISO strings on insert
- Reads as string, application converts to Date when needed
- Store in UTC (ISO format includes timezone)

```typescript
// Convert Date to ISO string on insert
const transactionDate = new Date('2025-11-22T10:30:00Z');
await db.insert(transactions).values({ 
  date: transactionDate.toISOString() 
});

// Reads as ISO string, convert to Date if needed
const result = await db.select().from(transactions);
const date = new Date(result[0].date); // Convert from ISO string to Date
```

### Currency Codes

Use **ISO 4217** three-letter codes:

- EUR, USD, GBP, etc.
- Stored as String(3)
- Validated via Zod schema

## Duplicate Detection

### Strategy

Transactions are considered duplicates if they match on:

1. **accountId** - Same account
2. **date** - Same transaction date
3. **externalId** - Same bank transaction ID

**Implementation**:

```sql
UNIQUE (accountId, date, externalId)
```

### Handling Missing externalId

If bank doesn't provide transaction IDs:

- Use combination of date + amount + description
- Hash the combination to create synthetic externalId
- Store hash in externalId field

```typescript
function generateExternalId(transaction: ParsedTransaction): string {
  if (transaction.externalId) {
    return transaction.externalId;
  }

  const data = `${transaction.date}|${transaction.amount}|${transaction.description}`;
  return createHash('sha256').update(data).digest('hex').substring(0, 32);
}
```

## Query Patterns

### Common Queries

**Get all transactions for an account**:

```typescript
import { eq, desc } from 'drizzle-orm';
import { transactions } from '@nodm/financier-db';

const results = await db
  .select()
  .from(transactions)
  .where(eq(transactions.accountId, 'LT000000000000000004'))
  .orderBy(desc(transactions.date));
```

**Get transactions in date range**:

```typescript
import { and, gte, lte, desc } from 'drizzle-orm';
import { transactions } from '@nodm/financier-db';

const results = await db
  .select()
  .from(transactions)
  .where(
    and(
      gte(transactions.date, new Date('2025-01-01').toISOString()),
      lte(transactions.date, new Date('2025-12-31').toISOString())
    )
  )
  .orderBy(desc(transactions.date));
```

**Get current balance for account**:

```typescript
import { eq, desc } from 'drizzle-orm';
import { transactions } from '@nodm/financier-db';

const [result] = await db
  .select({ balance: transactions.balance })
  .from(transactions)
  .where(eq(transactions.accountId, 'LT000000000000000004'))
  .orderBy(desc(transactions.date))
  .limit(1);
```

**Search by merchant**:

```typescript
import { like } from 'drizzle-orm';
import { transactions } from '@nodm/financier-db';

const results = await db
  .select()
  .from(transactions)
  .where(like(transactions.merchant, '%Amazon%'));
```

**Spending by category**:

```typescript
import { and, eq, gte, lte, sum, count } from 'drizzle-orm';
import { transactions } from '@nodm/financier-db';

const spending = await db
  .select({
    category: transactions.category,
    totalAmount: sum(transactions.amount),
    transactionCount: count(),
  })
  .from(transactions)
  .where(
    and(
      eq(transactions.type, 'debit'),
      gte(transactions.date, new Date('2025-11-01').toISOString()),
      lte(transactions.date, new Date('2025-11-30').toISOString())
    )
  )
  .groupBy(transactions.category);
```

## Data Validation

### At Import Time

Use Zod schemas from `@nodm/financier-types`:

```typescript
import { CreateTransactionInputSchema } from '@nodm/financier-types';

function validateTransaction(data: unknown) {
  return CreateTransactionInputSchema.parse(data);
}
```

### At Query Time

Drizzle provides full TypeScript inference:

```typescript
// TypeScript infers the exact shape
const [transaction] = await db
  .select()
  .from(transactions)
  .where(eq(transactions.id, 'some-uuid'));
```

## Performance Considerations

### Indexes

Current indexes optimize for:

- Account-specific queries (most common)
- Date range queries (very common)
- Merchant/category filtering (common)
- Duplicate detection (critical)

### Batch Operations

For importing large CSVs:

```typescript
import { transactions } from '@nodm/financier-db';

// Insert in batches of 1000
await db
  .insert(transactions)
  .values(transactionArray)
  .onConflictDoNothing(); // Skip duplicates
```

### Query Limits

Always use pagination for large result sets:

```typescript
import { transactions } from '@nodm/financier-db';

const results = await db
  .select()
  .from(transactions)
  .limit(100)
  .offset(0);
```

## Future Schema Extensions

### Planned Additions

1. **categories table**

   - Predefined category list
   - Category hierarchy (parent/child)
   - Custom categories per user

2. **tags table + transaction_tags join table**

   - Multiple tags per transaction
   - Tag-based filtering and analysis

3. **budgets table**

   - Monthly budget limits per category
   - Budget vs actual tracking

4. **recurring_transactions table**

   - Pattern detection for recurring charges
   - Subscription tracking

5. **notes table**
   - User notes on transactions
   - Timestamp and edit history

### Migration Path to PostgreSQL

For cloud deployment:

- Change datasource provider to "postgresql"
- Add UUID extension
- Adjust Decimal type mapping
- Add row-level security policies
- Add user authentication table

## Testing Data

### Test Database

Create separate test database:

```typescript
// In tests
process.env.DATABASE_URL = 'file:./test.db';
```

### Sample Data

Create factory functions for test data:

```typescript
function createTestAccount(overrides = {}) {
  return {
    id: 'TEST_ACCOUNT_001',
    type: 'checking',
    currency: 'EUR',
    bankCode: 'TEST_BANK',
    ...overrides,
  };
}

function createTestTransaction(overrides = {}) {
  return {
    id: uuid(),
    accountId: 'TEST_ACCOUNT_001',
    date: new Date('2025-11-22').toISOString(),
    amount: new Decimal('-50.00'),
    currency: 'EUR',
    description: 'Test transaction',
    type: 'debit',
    source: 'TEST_BANK',
    ...overrides,
  };
}
```

## Data Retention

### Current Policy

- Keep all data indefinitely
- No automatic deletion
- User can manually delete via future CLI commands

### Future Considerations

- Archival of old transactions (>5 years)
- Compression of historical data
- Export/backup utilities
